// @flow

/**
 * This function takes an `iterable` as argument and returns
 * a readable stream that repeatedly emits values generated by the emitter.
 *
 * @example
 * let readable, writable, values=[1,2,3], sum=0;
 *
 * // Create test streams
 *   readable = cycle( values );
 *   writable = createTestWritable( c => { sum+=c });
 *
 * // Connect the streams
 * const expected = 2 * values.reduce( (a, b) => a+b );
 *
 * connect(
 *   readable,
 *   take( 2 * values.length ),
 *   writable
 * ); // sum == expected
 */

import Pipe from "@pipes/core/pipe";
import { ReadableStream } from "@pipes/core/streams";

export default function cycle( iterator: Iterable<mixed> ): ReadableStream {

  // Check if not iterator
  // $FlowFixMe (https://github.com/facebook/flow/issues/1163)
  if ( !iterator[Symbol.iterator] ) {
    iterator = [ iterator ];
  }

  let
  { readable } : { readable: ReadableStream } = new Pipe( function* () {
    while ( true ) {
      yield* iterator;
    }

  }, { init: null });

  return readable;
}

// Browserify compat
if ( typeof module !== "undefined" )
  // $FlowFixMe
  module.exports = cycle;
